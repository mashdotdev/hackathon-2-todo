# Implementation Plan: Phase IV Local Kubernetes Deployment

**Branch**: `004-phase4-kubernetes` | **Date**: 2025-12-28 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/004-phase4-kubernetes/spec.md`

## Summary

Containerize the existing Todo application (FastAPI backend + Next.js frontend) using Docker multi-stage builds, deploy to a local Minikube Kubernetes cluster using Helm charts, and integrate kubectl-ai for AI-assisted cluster operations. The implementation adds health check endpoints, Kubernetes ConfigMaps/Secrets for externalized configuration, and optional Prometheus/Grafana monitoring.

## Technical Context

**Language/Version**: Python 3.13+ (backend), TypeScript 5.x (frontend), YAML (Kubernetes manifests)
**Primary Dependencies**: Docker, Minikube, Helm 3.x, kubectl, kubectl-ai
**Storage**: PostgreSQL (Neon Serverless - external, unchanged from Phase III)
**Testing**: Manual verification via kubectl, Helm test hooks
**Target Platform**: Local Kubernetes (Minikube with Docker driver)
**Project Type**: Web (backend + frontend + infrastructure)
**Performance Goals**: Pod startup <2 minutes, Helm install <5 minutes
**Constraints**: Minikube minimum 4GB RAM, 2 CPUs; images <500MB backend, <200MB frontend
**Scale/Scope**: Single cluster, 1-2 replicas per service, local development only

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Spec-Driven Development | PASS | Specification created via `/sp.specify`, plan via `/sp.plan` |
| II. No Manual Coding | PASS | All code generated by Claude Code from specifications |
| III. Test-First Development | PASS | Health endpoints testable via kubectl probes |
| IV. AI-Native Architecture | PASS | kubectl-ai for AI-assisted operations |
| V. Cloud-Native Deployment | PASS | Docker + Kubernetes + Helm as required |
| VI. Progressive Enhancement | PASS | Phase IV builds on Phase III, adds containerization |
| VII. Security-First | PASS | Secrets in K8s Secrets, non-root containers |
| VIII. Observability | PASS | /health, /ready endpoints; optional Prometheus |
| IX. Simplicity & YAGNI | PASS | Minimal viable K8s setup, no over-engineering |

## Project Structure

### Documentation (this feature)

```text
specs/004-phase4-kubernetes/
├── spec.md              # Feature specification
├── plan.md              # This file
├── research.md          # Technology decisions
├── data-model.md        # Kubernetes resource definitions
├── quickstart.md        # Deployment guide
├── contracts/           # API and schema contracts
│   ├── helm-values-schema.yaml
│   └── health-endpoints.yaml
├── checklists/
│   └── requirements.md  # Spec quality checklist
└── tasks.md             # Implementation tasks (via /sp.tasks)
```

### Source Code (repository root)

```text
backend/
├── src/
│   ├── api/routes/      # Existing API routes
│   ├── main.py          # Add /ready endpoint
│   └── ...
└── tests/

frontend/
├── src/
│   ├── app/
│   │   └── api/health/route.ts  # NEW: Health endpoint
│   └── ...
└── ...

infra/                   # NEW: Infrastructure directory
├── docker/
│   ├── backend.Dockerfile
│   └── frontend.Dockerfile
├── helm/
│   └── todo/
│       ├── Chart.yaml
│       ├── values.yaml
│       ├── secrets.example.yaml
│       └── templates/
│           ├── _helpers.tpl
│           ├── namespace.yaml
│           ├── backend-deployment.yaml
│           ├── backend-service.yaml
│           ├── frontend-deployment.yaml
│           ├── frontend-service.yaml
│           ├── ingress.yaml
│           ├── configmap-backend.yaml
│           ├── configmap-frontend.yaml
│           └── secret-db.yaml
└── k8s/                 # Optional raw manifests
```

**Structure Decision**: Extended web application structure with new `infra/` directory for Docker and Kubernetes artifacts. Backend and frontend directories remain unchanged except for new health endpoints.

## Complexity Tracking

No constitution violations requiring justification. The implementation follows all principles:
- Single Helm chart (not multiple)
- Minikube only (no cloud complexity)
- External database (no PostgreSQL container)
- Standard patterns throughout

## Implementation Phases

### Phase 1: Docker Containerization

**Objectives**:
- Create production-ready Dockerfiles for backend and frontend
- Implement multi-stage builds for minimal image sizes
- Ensure non-root user execution for security

**Deliverables**:
1. `infra/docker/backend.Dockerfile` - Multi-stage Python build
2. `infra/docker/frontend.Dockerfile` - Multi-stage Node.js build with standalone output
3. `.dockerignore` files for both projects

**Key Decisions**:
- Python 3.13-slim base for backend (~100MB final)
- Node 20-alpine base for frontend (~150MB final)
- UV package manager for reproducible Python builds
- Next.js standalone output mode

### Phase 2: Health Check Endpoints

**Objectives**:
- Add `/ready` endpoint to backend (database connectivity check)
- Add `/api/health` endpoint to frontend
- Ensure existing `/health` endpoint remains for liveness

**Deliverables**:
1. Backend: Update `src/main.py` with `/ready` endpoint
2. Frontend: Create `src/app/api/health/route.ts`

**Key Decisions**:
- Liveness (`/health`): Returns OK if process running
- Readiness (`/ready`): Returns OK only when DB connected

### Phase 3: Helm Chart Development

**Objectives**:
- Create comprehensive Helm chart for entire application
- Support configuration via values.yaml
- Include all Kubernetes resources

**Deliverables**:
1. `infra/helm/todo/Chart.yaml` - Chart metadata
2. `infra/helm/todo/values.yaml` - Default configuration
3. `infra/helm/todo/templates/*` - All resource templates

**Key Decisions**:
- Single umbrella chart (not subcharts)
- NGINX Ingress via Minikube addon
- Secrets managed via separate file (not in values.yaml)

### Phase 4: AIOps Integration

**Objectives**:
- Document kubectl-ai installation and usage
- Provide example queries for common operations
- Optional kagent documentation

**Deliverables**:
1. Update `quickstart.md` with kubectl-ai section
2. Example queries in documentation

### Phase 5: Monitoring (Optional)

**Objectives**:
- Document Prometheus/Grafana deployment
- Add metrics endpoint to backend (if time permits)

**Deliverables**:
1. Prometheus installation instructions in quickstart.md
2. Optional: `prometheus_fastapi_instrumentator` integration

## API Contracts

### Health Endpoints

| Endpoint | Method | Response | Purpose |
|----------|--------|----------|---------|
| `/health` | GET | `{"status": "healthy"}` | Liveness probe |
| `/ready` | GET | `{"status": "ready", "checks": {...}}` | Readiness probe |
| `/api/health` | GET | `{"status": "ok"}` | Frontend liveness |

See `contracts/health-endpoints.yaml` for full OpenAPI specification.

### Helm Values Schema

See `contracts/helm-values-schema.yaml` for JSON Schema defining all configurable values.

## Risk Mitigation

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Minikube resource exhaustion | Medium | High | Document minimum requirements, provide resource limits |
| Docker image build failures | Low | Medium | Multi-stage builds, cached layers |
| Database connectivity from containers | Low | High | Verify Neon allows external connections |
| Windows compatibility issues | Medium | Medium | WSL 2 requirement documented |

## Success Metrics

| Metric | Target | Verification |
|--------|--------|--------------|
| Helm install time | <5 minutes | `time helm install ...` |
| Pod startup time | <2 minutes | `kubectl wait --timeout=120s` |
| Backend image size | <500MB | `docker images` |
| Frontend image size | <200MB | `docker images` |
| kubectl-ai functionality | Working | Manual test with queries |

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| Phase III application | Internal | Complete |
| Docker Desktop | External | User prerequisite |
| Minikube | External | User prerequisite |
| Helm 3.x | External | User prerequisite |
| Neon PostgreSQL | External | Unchanged from Phase III |

## Next Steps

After plan approval:
1. Run `/sp.tasks` to generate implementation tasks
2. Implement in priority order (P1 first)
3. Create PHR for each implementation session
4. Verify success criteria before marking complete

---

**Plan Status**: Ready for `/sp.tasks`
**Artifacts Generated**:
- research.md
- data-model.md
- quickstart.md
- contracts/helm-values-schema.yaml
- contracts/health-endpoints.yaml
